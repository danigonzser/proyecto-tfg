\chapter{Análisis del problema}

En este capítulo, se explicará la metodología seguida y se presentará un análisis de requisitos. Comenzaremos entendiendo el contexto del problema e identificando los requisitos a través de las historias de usuario y los usuarios identificados previamente. Posteriormente, se elaborará el código generado del DDD que modele las estructuras de datos necesarias para definir el problema.

Para garantizar una estructura coherente, organizada, eficiente y alineada con las mejores prácticas de desarrollo de software, se ha optado por un enfoque ágil junto con \textit{domain driven design} (DDD). Este enfoque permite profundizar en la comprensión y modelado del problema, a la vez el desarrollo se hace de forma incremental, continua y adaptativa.

\section{Domain driven design}

En esta sección, se analizará el problema utilizando el diseño orientado al dominio (DDD), una metodología introducida por Eric Evans. Esta metodología de desarrollo de software nos ayudará a comprender y modelar el dominio empresarial, asegurando que nuestras soluciones se alineen con las necesidades específicas de los usuarios y del negocio.

DDD aborda la complejidad enfocándose en el ``dominio'' y promoviendo un ``lenguaje ubicuo'', un lenguaje común entre desarrolladores y partes interesadas para garantizar que el software refleje con precisión el ámbito empresarial. La modelización en DDD no busca crear el modelo más realista, sino uno útil y apropiado para su propósito~\cite{evans2004domain}.

El lenguaje ubicuo debe basarse en el modelo del dominio por lo que debe ser riguroso y preciso para evitar cualquier tipo de ambigüedad. De igual manera, debe ser especificado en una etapa temprana del proyecto por eso, está antes de todo el proceso. A continuación, algunos de los términos del lenguaje ubicuo:

\begin{itemize}
    \item \textbf{Meme}: imagen, vídeo o texto que difunde un mensaje que suele ser humorístico.
    \item \textbf{Plantilla}: formato base sobre la que se elaboran los memes.
    \item \textbf{Catálogo de memes}: almacenamiento centralizado de memes.
    \item \textbf{Colaborador}: usuario que puede editar un meme.
    \item \textbf{Visualizador}: usuario que puede ver un meme.
    \item \textbf{Búsqueda avanzada}: sistema de búsqueda en el catálogo de memes que permite filtrar memes por diferentes criterios.
\end{itemize}

Además de DDD, se han contemplado alternativas como el \textit{domain mapping} que facilita la visualización del dominio y \textit{volatility decomposisiton} que permite identificar las partes del sistema que son más propensas a cambios. Empresas como \textit{Netflix}, \textit{Uber} y \textit{Airbnb} han adoptado DDD con notable éxito como se detalla en esta \href{https://blog.bitsrc.io demystifying-domain-driven-design-ddd-in-modern-software-architecture-b57e27c210f7}{publicación}.

Es importante destacar que DDD no abandona la filosofía ágil. Aunque esta metodología no está vinculada a otra metodología en particular, se orienta hacia la nueva familia de ``procesos de desarrollo ágil''. Específicamente, asume que aplican dos prerrequisitos para aplicar el enfoque presentado en este libro: que el desarrollo sea iterativo y que la relación sea estrecha entre quiénes manejan el dominio y quiénes construyen el \textit{software}.

\subsection{Análisis de requisitos}

Los requisitos han sido identificados a partir de las historias de usuario~\ref{sec:historias_de_usuario} anteriormente definidas y los usuarios identificados en~\ref{sec:usuarios_identificados}. Estos requisitos son los que llamamos los requisitos básicos o esenciales a partir de los cuales se desarrollará el diseño.

\begin{itemize}
    \item \textbf{Se debe proporcionar un editor de memes.}
    \begin{itemize}
        \item[-] Historias de usuario requeridas: HU01, HU04 y HU02.
    \end{itemize}
    \item \textbf{Se debe proporcionar un catálogo de memes predefinidos.}
    \begin{itemize}
        \item[-] Historias de usuario requeridas: HU01, HU02 y HU03.
    \end{itemize}
    \item \textbf{La solución debe poder permitir colaboración en la creación de memes.}
    \begin{itemize}
        \item[-] Historias de usuario requeridas: HU04.
    \end{itemize}
    \item \textbf{Se debe proporcionar un sistema de búsqueda avanzada de memes.}
    \begin{itemize}
        \item[-] Historias de usuario requeridas: HU03.
    \end{itemize} 
\end{itemize}


\section{Selección del lenguaje de programación}

Para la elaboración del código generado del DDD, se va a realizar un proceso de selección del lenguaje de programación en el que se va a escribir este código y posteriormente, realizar el proyecto.

\subsection{Criterios de búsqueda}

Los criterios que se han fijado para la búsqueda del lenguaje son los siguientes:

\begin{itemize}
    \item Permite crear interfaces que se tendrán que implementar en una clase.
    \item Lenguaje íntimamente relacionado con el desarrollo web.
\end{itemize}

\subsection{Criterios de selección}

Las propuestas encontradas tras los criterios de búsqueda serán evaluadas según:

\begin{itemize}
    \item Facilidad de uso.
    \item Popularidad.
    \item Fiabilidad y seguridad.
    \item Documentación.
    \item Comunidad.
\end{itemize}

\subsection{Propuestas}

\subsubsection{TypeScript}

TypeScript, un superconjunto de JavaScript desarrollado por Microsoft y publicado en octubre 2012, extiende JavaScript con una sintaxis basada en un sistema de tipos estático para ofrecer una detección temprana de errores y una integración más profunda con los editores de código.

Diseñado para compilarse a JavaScript, TypeScript es compatible y válido con cualquier código JavaScript. Esta extensión facilita la escritura y el mantenimiento de aplicaciones a gran escala al proporcionar inferencia de tipos y herramientas avanzadas sin necesidad de código adicional. Con TypeScript, los desarrolladores pueden definir tipos personalizados y recibir advertencias de errores directamente en el editor, lo que mejora significativamente la seguridad y eficiencia del proceso de desarrollo. A lo largo de los años, TypeScript ha ganado popularidad por su capacidad para mejorar la calidad del código y facilitar el trabajo en proyectos complejos.

\begin{itemize}
    \item[\bien] \textbf{Facilidad de uso}: al ser un superconjunto de JavaScript, es fácil de aprender.
    \item[\bien] Popularidad: JavaScript es el lenguaje más popular según esta \href{https://survey.stackoverflow.co/2023/#technology-most-popular-technologies}{encuesta} de StackOverflow, por lo que TypeScript también lo es.
    \item[\esp] Fiabilidad y seguridad: al poseer un sistema de tipos fuerte y estático, se evitan errores mientras se escribe el código.
    \item[\bien] Documentación: la documentación final junto con la de JavaScript es muy completa.
    \item[\bien] Comunidad: al ser un lenguaje de Microsoft y superconjunto de JavaScript tiene una comunidad muy activa y completa
\end{itemize}

\subsection{Conclusión}

Al ser TypeScript la única propuesta que se ajusta a los criterios de búsqueda y se ajusta bastante bien a los criterios de selección se ha decidido que el lenguaje de programación en el que se va a escribir el código será TypeScript.